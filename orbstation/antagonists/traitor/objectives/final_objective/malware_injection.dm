#define APCS_REQUIRED_FOR_MALF 10
#define INJECTOR_HACK_TIME 20 SECONDS
#define MAXIMUM_HACKED_APCS 20

#define POSSIBLE_DEPARTMENTS list(\
	"Medbay" = list(/area/station/medical, /area/station/security/checkpoint/medical, /area/station/command/heads_quarters/cmo,),\
	"Science Division" = list(/area/station/science, /area/station/security/checkpoint/science, /area/station/command/heads_quarters/rd,),\
	"Engineering Division" = list(/area/station/engineering, /area/station/security/checkpoint/engineering,\
		/area/station/command/heads_quarters/ce, /area/station/maintenance/disposal/incinerator,),\
	"Cargo Bay" = list(/area/station/cargo, /area/station/security/checkpoint/supply, /area/station/command/heads_quarters/qm,),)

/datum/traitor_objective/ultimate/malware_injection
	name = "Hack %NUMBER% APCs, and inject the AI with malware in the %DEPT%"
	description = "Press the button to call down a drop pod containing a malware injector and a circuit board for a malware injection console. \
	Use the injector to hack %NUMBER% APCs, and then go to the %DEPT% to build the console. Note that the console will not work in command staff offices, \
	which are protected. Use the injector on the console to begin corrupting the AI. \
	WARNING: This process will alert the AI and trigger nearby alarms."

	///Name of the department where the Syndicate AI upload needs to be built.
	var/department_name
	///Typecache of area where the Syndicate AI upload needs to be built.
	var/console_area
	///Checker on whether the pod has been called or not.
	var/sent_injector = FALSE

/datum/traitor_objective/ultimate/malware_injection/can_generate_objective(generating_for, list/possible_duplicates)
	. = ..()
	if(!.)
		return FALSE

	var/list/active_ais = active_ais() // fetch a list of alive, online AIs
	if(!LAZYLEN(active_ais())) // don't generate this objective if there's no AIs
		return FALSE
	for(var/mob/living/silicon/ai in active_ais)
		if(IS_MALF_AI(ai)) // don't generate this objective if there's already a malf AI
			return FALSE

/datum/traitor_objective/ultimate/malware_injection/generate_objective(datum/mind/generating_for, list/possible_duplicates)


	department_name = pick(POSSIBLE_DEPARTMENTS)
	console_area = typecacheof(POSSIBLE_DEPARTMENTS[department_name])
	replace_in_name("%NUMBER%", APCS_REQUIRED_FOR_MALF)
	replace_in_name("%DEPT%", department_name)
	return TRUE

#undef POSSIBLE_DEPARTMENTS

/datum/traitor_objective/ultimate/malware_injection/generate_ui_buttons(mob/user)
	var/list/buttons = list()
	if(!sent_injector)
		buttons += add_ui_button("", "Pressing this will call down a pod with the malware injector kit.", "robot", "malware_kit")
	return buttons

/datum/traitor_objective/ultimate/malware_injection/ui_perform_action(mob/living/user, action)
	. = ..()
	switch(action)
		if("malware_kit")
			if(sent_injector)
				return
			sent_injector = TRUE

			var/obj/item/storage/box/syndie_kit/box = new()
			var/obj/item/malware_injector/injector = new(box)
			injector.required_area = src.console_area
			var/obj/item/circuitboard/computer/malware/circuit = new(box)
			circuit.console_area = src.console_area

			podspawn(list(
				"target" = get_turf(user),
				"style" = STYLE_SYNDICATE,
				"spawn" = box,
			))

/obj/machinery/power/apc/Initialize(mapload)
	. = ..()
	register_context()

/// Adds a tooltip telling you how to hack APCs
/obj/machinery/power/apc/add_context(atom/source, list/context, obj/item/held_item, mob/user)
	. = ..()
	if (istype(held_item, /obj/item/malware_injector))
		context[SCREENTIP_CONTEXT_LMB] = "Hack APC"
		return CONTEXTUAL_SCREENTIP_SET
	return .

// MALWARE INJECTOR DEVICE

/obj/item/malware_injector
	name = "malware injector"
	desc = "A device engineered for the Syndicate on behalf of S.E.L.F. It's designed to hack into APCs for processing power, \
	and then inject malware into an AI's systems through a malware injection console."
	icon = 'icons/obj/device.dmi'
	icon_state = "weakpoint_locator"
	inhand_icon_state = "weakpoint_locator"
	lefthand_file = 'icons/mob/inhands/items/devices_lefthand.dmi'
	righthand_file = 'icons/mob/inhands/items/devices_righthand.dmi'
	throwforce = 0
	w_class = WEIGHT_CLASS_SMALL
	throw_speed = 3
	throw_range = 5

	/// Set to TRUE when the injector is hacking an APC or transfering the virus to a malware upload console.
	var/hacking = FALSE
	/// List of APCs that have been hacked by the injector. Transfered to the malware upload console.
	var/list/hacked_apcs = list()
	/// Number of APCs that need to be hacked in order to begin corrupting the AI.
	var/apcs_required = APCS_REQUIRED_FOR_MALF
	/// After the malware is transferred to the malware injection console, the injector can no longer be used.
	var/spent = FALSE
	/// Type cache of areas you can use the computer in
	var/required_area

/obj/item/malware_injector/Initialize(mapload)
	. = ..()
	register_context()

/// Adds a tooltip telling you what using this inhand does.
/obj/item/malware_injector/add_context(atom/source, list/context, obj/item/held_item, mob/user)
	. = ..()
	context[SCREENTIP_CONTEXT_LMB] = "Check area upload validity"
	return CONTEXTUAL_SCREENTIP_SET

/// Called when item is used in hand, reports whether you are in a valid location.
/obj/item/malware_injector/attack_self(mob/user)
	. = ..()
	var/area/current_area = get_area(src)
	if(!is_type_in_typecache(current_area, required_area))
		balloon_alert(user, "invalid upload location")
		return
	balloon_alert(user, "area suitable for upload")

/// Called when you use the item on something. Try to hack an APC if you use it on one.
/obj/item/malware_injector/afterattack(atom/target, mob/user, proximity)
	. = ..()
	var/atom/A = target
	if(!proximity)
		return
	if(istype(target, /obj/machinery/power/apc))
		if(hacking)
			to_chat(user, span_alert("You're already hacking something with [src]!"))
			return
		if(!can_hack(target, user))
			playsound(user, 'sound/machines/buzz-sigh.ogg', 30, TRUE)
			return
		hack_apc(target, user)
	log_combat(user, A, "used a malware injector on")

/// Checks if the user can hack the APC.
/obj/item/malware_injector/proc/can_hack(obj/machinery/power/apc/target, mob/living/user)
	if(!istype(user))
		return FALSE
	if(!user.mind.has_antag_datum(/datum/antagonist/traitor))
		to_chat(user, span_warning("You have no idea how to use [src]."))
		return FALSE
	if(spent)
		to_chat(user, span_alert("[src] is no longer functional."))
		return FALSE
	if(hacked_apcs.len >= MAXIMUM_HACKED_APCS)
		to_chat(user, span_alert("[src] has already hacked the maximum amount of APCs."))
		return FALSE
	if(!target.operating || target.shorted || target.machine_stat & BROKEN)
		to_chat(user, span_alert("[target] is non-functional, and won't respond to [src]."))
		return FALSE
	if(target.malfhack || target.obj_flags & EMAGGED)
		to_chat(user, span_alert("[target] is already hacked, and isn't responding to [src]."))
		return FALSE
	return TRUE

/// Hacks an APC after a timer (see INJECTOR_HACK_TIME) as long as the user stays still and keeps the injector in their active hand. Makes the APC act as though emagged.
/obj/item/malware_injector/proc/hack_apc(obj/machinery/power/apc/target, mob/living/user)
	if(!istype(user) || !istype(target) || loc != user)
		return

	flick("apc-spark", target)
	playsound(target, SFX_SPARKS, 75, TRUE, SHORT_RANGE_SOUND_EXTRARANGE)
	user.visible_message(span_danger("[user] holds [src] up to [target] and begins pressing buttons!"), span_notice("You activate [src] and begin to hack [target]. Keep [src] in your active hand and stand still."))
	hacking = TRUE

	if(!do_after(user, INJECTOR_HACK_TIME, src, IGNORE_SLOWDOWNS, extra_checks = CALLBACK(src, PROC_REF(can_hack), target, user)))
		playsound(user, 'sound/machines/buzz-sigh.ogg', 30, TRUE)
		to_chat(user, span_alert("Hack aborted."))
		hacking = FALSE
		return

	target.locked = TRUE
	target.coverlocked = TRUE
	target.obj_flags |= EMAGGED // this is just to make the APC bluescreen
	flick("apc-spark", target)
	playsound(target, SFX_SPARKS, 75, TRUE, SHORT_RANGE_SOUND_EXTRARANGE)
	hacked_apcs += target
	hacking = FALSE
	to_chat(user, span_notice("Hack successful. [length(hacked_apcs)] APC[length(hacked_apcs)>1?"s":""] hacked. [max(0, APCS_REQUIRED_FOR_MALF - length(hacked_apcs))] more to go."))
	target.update_appearance()

// MALWARE INJECTION CONSOLE

// 15 * 10 = 2 minutes and 30 seconds total
#define TIME_PER_STAGE 15 SECONDS
#define CORRUPTION_STAGES 10

/obj/machinery/computer/malware
	name = "malware injection console"
	desc = "A highly illegal console used by the Syndicate to inject an AI with malware."
	icon_screen = "commsyndie"
	icon_keyboard = "syndie_key"
	circuit = /obj/item/circuitboard/computer/malware

	///AI to inject malware into.
	var/mob/living/silicon/ai/current = null
	///Set to TRUE when transfering the virus into the console with a malware injector, and while the AI is being corrupted.
	var/injecting = FALSE
	///Set to TRUE when trying to resume the malware injection after it gets interrupted for whatever reason.
	var/resuming = FALSE
	///Current stage of corruption. The AI will become a malf AI when this number reaches CORRUPTION_STAGES.
	var/corruption_stage = 0
	///List of hacked APCs. This data is transferred to this computer through the malware injector. Used to retroactively connect the malf AI to the hacked APCs.
	var/list/hacked_apcs = list()
	///Typecache of areas that the computer needs to be in to work
	var/required_area

/obj/machinery/computer/malware/Initialize(mapload)
	. = ..()
	register_context()

/// Adds a tooltip telling you how to upload malware
/obj/machinery/computer/malware/add_context(atom/source, list/context, obj/item/held_item, mob/user)
	. = ..()
	if (istype(held_item, /obj/item/malware_injector))
		context[SCREENTIP_CONTEXT_LMB] = "Upload malware"
		return CONTEXTUAL_SCREENTIP_SET

	context[SCREENTIP_CONTEXT_LMB] = "Select target AI"
	return CONTEXTUAL_SCREENTIP_SET

/// Get the required location from the circuit
/obj/machinery/computer/malware/on_construction()
	. = ..()
	circuit.configure_machine(src)

/obj/machinery/computer/malware/interact(mob/living/user)
	if(!istype(user))
		return
	if(!user.mind.has_antag_datum(/datum/antagonist/traitor))
		to_chat(user, span_alert("Access denied."))
		return
	if(injecting)
		to_chat(user, span_alert("ERROR: Malware injection in progress."))
		return
	if(!injecting && corruption_stage && !resuming) // the injection had been aborted at some point
		user.visible_message(span_danger("[user] hunches over [src] and begins typing away!"), span_notice("You start typing on [src] to resume the malware injection."))
		resuming = TRUE
		if(!do_after(user, INJECTOR_HACK_TIME, src, IGNORE_SLOWDOWNS, extra_checks = CALLBACK(src, PROC_REF(inject_check))))
			resuming = FALSE
			return
		resuming = FALSE
		to_chat(user, span_boldnotice("Resuming malware injection."))
		// time to go loud!
		trigger_alarm(user) // set off the alarm, close and lock all doors in the area, alert the AI in big bold letters
		announce_corruption()
		advance_corruption_stage(user)
		return
	current = select_active_ai(user) // z-level does not matter for this
	if(!current)
		to_chat(user, span_alert("No active AIs detected!"))
	else
		to_chat(user, span_notice("[current.name] selected for malware injection."))

/obj/machinery/computer/malware/attackby(obj/item/O, mob/living/user, params)
	if(!istype(O, /obj/item/malware_injector))
		return ..()

	var/obj/item/malware_injector/injector = O
	if(machine_stat & (NOPOWER|BROKEN|MAINT))
		return
	if(!istype(user))
		return
	if(!user.mind.has_antag_datum(/datum/antagonist/traitor))
		to_chat(user, span_warning("You have no idea how to use [injector]."))
		return
	if(injector.spent)
		to_chat(user, span_alert("[injector] is no longer functional."))
		return
	if(injector.hacking)
		to_chat(user, span_alert("[injector] is already hacking something else."))
		return
	if(length(injector.hacked_apcs) < APCS_REQUIRED_FOR_MALF)
		to_chat(user, span_alert("[injector] has not hacked enough APCs to inject the malware. [APCS_REQUIRED_FOR_MALF - length(injector.hacked_apcs)] more needed."))
		return
	if(!current)
		to_chat(user, span_alert("You haven't selected anything to inject malware into!"))
		return
	if(!inject_check())
		to_chat(user, span_alert("Upload failed! Check to make sure [current.name] is functioning properly."))
		current = null
		return

	var/area/current_area = get_area(src)
	if(!is_type_in_typecache(current_area, required_area))
		to_chat(user, span_alert("Upload failed! Unable to establish connection to [current.name] in this area."))
		return
	begin_injection(injector, user)

/obj/machinery/computer/malware/screwdriver_act(mob/living/user, obj/item/I)
	if(injecting)
		to_chat(user, span_alert("ERROR: Malware injection in progress."))
		return FALSE
	return ..()

/// Checks if there's a currently selected AI, and that the AI is not malf or dead, and that the console still has a circuit board and is powered.
/obj/machinery/computer/malware/proc/inject_check()
	if(!current)
		return FALSE
	if(!isAI(current) || IS_MALF_AI(current) || current.stat == DEAD)
		return FALSE
	if(!circuit || machine_stat & (NOPOWER|BROKEN|MAINT))
		return FALSE
	return TRUE

/// Begins the process of injecting the AI with malware, transfering the list of hacked APCs to the console and making the malware injector no longer functional.
/obj/machinery/computer/malware/proc/begin_injection(obj/item/malware_injector/injector, mob/living/user)
	if(injector.hacking || injecting) // just in case
		return

	user.visible_message(span_danger("[user] holds [injector] up to [src] and begins pressing buttons!"), span_notice("You activate [injector] and begin transferring the virus to [src]. Keep [injector] in your active hand and stand still."))
	injector.hacking = TRUE
	injecting = TRUE

	if(!do_after(user, INJECTOR_HACK_TIME, src, IGNORE_SLOWDOWNS, extra_checks = CALLBACK(src, PROC_REF(inject_check))))
		playsound(user, 'sound/machines/buzz-sigh.ogg', 30, TRUE)
		to_chat(user, span_warning("Transfer aborted."))
		injector.hacking = FALSE
		injecting = FALSE
		return

	injector.hacking = FALSE
	injector.spent = TRUE
	hacked_apcs = injector.hacked_apcs.Copy()
	to_chat(user, span_boldnotice("Transfer complete. [src] begins injecting the virus into [current]'s mainframe!"))
	// time to go loud!
	trigger_alarm(user) // set off the alarm, close and lock all doors in the area, alert the AI in big bold letters
	announce_corruption()
	advance_corruption_stage(user)

/// Increases the corruption stage of the AI after a timer (see TIME_PER_STAGE). Aborts if anything happens to the AI or the console.
/obj/machinery/computer/malware/proc/advance_corruption_stage(mob/living/user)
	if(!do_after(user, TIME_PER_STAGE, src, IGNORE_USER_LOC_CHANGE | IGNORE_TARGET_LOC_CHANGE | IGNORE_HELD_ITEM | IGNORE_INCAPACITATED | IGNORE_SLOWDOWNS, extra_checks = CALLBACK(src, PROC_REF(inject_check))))
		if(!(machine_stat & (BROKEN|NOPOWER|MAINT)))
			say("FATAL ERROR. UPLOAD ABORTED.")
		injecting = FALSE
		// this does not lift the alarm or uncorrupt the AI's laws (the RD should go to a law upload console for that)
		return

	corruption_stage++
	announce_corruption()

	if(corruption_stage != CORRUPTION_STAGES) // at full corruption the AI will go malf, which already shows laws
		current.laws.corrupt_laws(corruption_stage)
		current.laws.show_laws(current)

	if(corruption_stage == CORRUPTION_STAGES)
		finish_injection(user)
		return

	advance_corruption_stage(user)

/// Makes the AI a malf AI, adds nuke objective, links hacked APCs and gives 10 processing power for each one, and finally breaks this upload console.
/obj/machinery/computer/malware/proc/finish_injection(mob/living/user)
	if(!(machine_stat & (BROKEN|NOPOWER|MAINT)))
		say("UPLOAD COMPLETE.")
	injecting = FALSE
	var/datum/antagonist/malf_ai/malf = new(give_objectives = FALSE)
	malf.should_give_codewords = FALSE
	var/datum/objective/nuclear/nuke_objective = new
	nuke_objective.owner = current.mind
	malf.objectives += nuke_objective
	current.mind.add_antag_datum(malf)
	current.malf_picker.processing_time = 0
	// time to link those APCs to the malf AI, finally
	for(var/obj/machinery/power/apc/linked_apc in hacked_apcs)
		if(!linked_apc)
			continue
		if(!linked_apc.operating || linked_apc.shorted || linked_apc.machine_stat & (BROKEN|NOPOWER))
			continue
		linked_apc.aidisabled = FALSE
		linked_apc.obj_flags &= ~EMAGGED
		linked_apc.malfai = current
		linked_apc.malfhack = TRUE
		current.malf_picker.processing_time += 5 // 5 processing power per hacked APC
	atom_break(ENERGY)

/// Sets off the fire alarm in each subarea of the department. Alerts the AI.
/obj/machinery/computer/malware/proc/trigger_alarm(mob/living/user)
	var/list/dept_areas = list()
	for (var/areapath in required_area)
		dept_areas += get_areas(areapath)
	dept_areas += get_areas()
	// trigger all fire alarms in the department
	for(var/area/alarmed_area as anything in dept_areas)
		if(alarmed_area)
			alarmed_area.trigger_fire_alarms(user)
	var/message = "UNAUTHORIZED CODE INJECTION DETECTED. SYSTEM INTEGRITY FAILING."
	to_chat(current, span_userdanger(span_big("[message]")))
	current.radio.talk_into(current, "[message]") // and everyone else

/// The console and the AI announce the corruption percentage of the AI. The AI does so over the radio. The percentage is slightly randomized for flavor.
/obj/machinery/computer/malware/proc/announce_corruption()
	if(machine_stat & (BROKEN|NOPOWER|MAINT) || !current)
		return
	var/corruption_calculation = max(1, round((100 / CORRUPTION_STAGES) * corruption_stage + rand(-3, 3)))
	if(corruption_stage == CORRUPTION_STAGES)
		corruption_calculation = 100
	var/message = "AI CORE CORRUPTION AT [corruption_calculation]%"
	say(message)
	to_chat(current, span_userdanger("WARNING: [message]")) // alert the AI in red letters so it can't possibly miss it
	current.radio.talk_into(current, "WARNING: [message]") // and everyone else
	playsound(src, 'sound/effects/alert.ogg', 50, TRUE)
	playsound(current, 'sound/effects/alert.ogg', 50, TRUE)

// MISC PROCS

/// Triggers fire alarms in the area, as though there was a fire.
/area/proc/trigger_fire_alarms(mob/user)
	for(var/obj/machinery/firealarm/alarm in firealarms)
		alarm.alarm(user)

/// Filters out every law an AI has, replacing random characters with symbols.
/datum/ai_laws/proc/corrupt_laws(corruption_stage = 1, base_replace_prob = 6, prob_per_stage = 1.5)
	var/n = 1
	var/new_law
	for(var/law in hacked) // hacked laws have a lower chance to get corrupted
		if (length(law) > 0)
			new_law = scramble_message_replace_chars(law, replaceprob = base_replace_prob + (prob_per_stage / 2) * corruption_stage)
			hacked -= hacked[n]
			hacked.Insert(n, new_law)
		n++

	n = 1
	for(var/law in ion)
		if (length(law) > 0)
			new_law = scramble_message_replace_chars(law, replaceprob = base_replace_prob + prob_per_stage * corruption_stage)
			ion -= ion[n]
			ion.Insert(n, new_law)
		n++

	n = 1
	for(var/law in inherent)
		if (length(law) > 0)
			new_law = scramble_message_replace_chars(law, replaceprob = base_replace_prob + prob_per_stage * corruption_stage)
			inherent -= inherent[n]
			inherent.Insert(n, new_law)
		n++

	n = 1
	for(var/law in supplied)
		if (length(law) > 0)
			new_law = scramble_message_replace_chars(law, replaceprob = base_replace_prob + prob_per_stage * corruption_stage)
			supplied -= supplied[n]
			supplied.Insert(n, new_law)
		n++

// CIRCUITBOARD

/obj/item/circuitboard/computer/malware
	name = "Malware Injection Console (Computer Board)"
	greyscale_colors = COLOR_THEME_OPERATIVE
	build_path = /obj/machinery/computer/malware
	/// Type cache of areas this computer can function in
	var/console_area

/obj/item/circuitboard/computer/malware/configure_machine(obj/machinery/computer/malware/machine)
	if (!istype(machine))
		CRASH("Malware injection board attempted to configure incorrect machine type: [machine] ([machine?.type])")
	machine.required_area = src.console_area

#undef TIME_PER_STAGE
#undef CORRUPTION_STAGES
#undef APCS_REQUIRED_FOR_MALF
#undef INJECTOR_HACK_TIME
